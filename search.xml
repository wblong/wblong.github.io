<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现string类及右值和左值]]></title>
    <url>%2F2019%2F05%2F06%2F%E7%8E%B0string%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class string&#123;public： String() //初始化 : _pstr(new char[1]) &#123;&#125; String(const char * pstr ); //普通构造函数: _pstr(new char[strlen(pstr) + 1]())&#123; strcpy(_pstr,pstr);&#125; String(const String &amp; rhs); //复制构造函数（深度拷贝）: _pstr(new char[strlen(pstr) + 1]())&#123; strcpy(_pstr, rhs.pstr);&#125; String(String &amp;&amp; rhs); //移动构造函数,右值引用: _pstr(rhs._pstr)&#123; rhs.pstr = NULL;&#125; String &amp; operator=(const String &amp; rhs) //重载赋值运算符函数&#123; if(this != &amp; rhs) &#123; delete [] _pstr; _pstr = new char[strlen(rhs._pstr) + 1](); strcpy(_pstr, rhs._pstr); &#125; return *this;&#125;String &amp; operator=(String &amp;&amp; rhs) //移动赋值运算符函数&#123; if(this != &amp;rhs) &#123; delete [] _pstr; _pstr = rhs._pstr; rhs._pstr = NULL; &#125; return * this;&#125; //析构函数~String()&#123; delete [] _pstr;&#125; //重载输出流运算符友元函数 friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp; os, const String &amp; rhs); private: char * _pstr;//私有数据成员&#125;; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const String &amp; rhs)&#123; os &lt;&lt; rhs._pstr; return os;&#125; 注意123456void f_ck(int &amp; i) &#123; i++;&#125;... f_ck(1); // 编译不通过，VS答曰：非常量的引用值必须是左值。... &amp; 是左值引用 ，所谓左值就是实际在运行时内存中存在的值，而不是 1 这种写死在运行代码中的值。 返回引用的生命周期问题1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Good &#123;public: string goodname; Good() &#123; goodname = &quot;not_good&quot;; cout &lt;&lt; &quot;Good constructed&quot; &lt;&lt; endl; &#125; ~Good() &#123; cout &lt;&lt; &quot;Good destoyed&quot; &lt;&lt; endl; &#125;&#125;;class Warehouse &#123;public: Good &amp; good; Warehouse(Good &amp; good) : good(good) &#123; &#125; //错误将栈变量赋值给左值引用，栈的生命周期要小于左值引用 static Warehouse* WarehouseBuilder() &#123; Good good; return new Warehouse(good); &#125;&#125;;int main()&#123; Warehouse * warehouse = Warehouse::WarehouseBuilder(); cout &lt;&lt; warehouse-&gt;good.goodname &lt;&lt; endl; getchar(); return 0;&#125; &amp;&amp;，就是右值引用了，右值是出现在等式右边的值。 右值 &amp;&amp; 显然不能放在等号左边。 123456789101112class Whore &#123;public: string nickname;&#125;;class Brothel &#123;public: Whore &amp;&amp; whore_; Brothel(Whore &amp;&amp; whore): whore_(whore) &#123; //编译不通过，无法将右值引用绑定到左值 &#125; //whore_=whore 不能&#125;; 相似的123456789101112class Whore &#123;public: string nickname;&#125;;class Brothel &#123;public: Whore &amp;&amp; whore_; Brothel(Whore &amp;&amp; whore) &#123; // 编译不通过，“Brothel::whore_”: 必须初始化引用 whore_ = whore; &#125;&#125;; 1234567891011121314151617class Whore &#123;public: string nickname;&#125;;class Brothel &#123;public: Whore &amp; whore_; Brothel(Whore &amp;&amp; whore): whore_(whore) &#123; &#125;&#125;;... Whore &amp;&amp; whore = Whore(); Brothel(whore); // 编译不通过... 用 type &amp;&amp; r 去引用一个匿名的右值（右值当然是匿名的），确实延长了其生命周期，但是这有个限度，就是不能超过栈的生命周期。 c++ 中的左值就像指针，它可以捕获实实在在的实体，但是我们要注意被捕获值的生命周期。不要随便把生命周期和栈同步的实体传给了它； 右值其实也是指针，但是它功能是专门捕获匿名的实体（可以理解为编译产生的中间变量）。同时我们要注意，右值在定义时捕获了实体以后，右值的名字就变成了被捕获的实体。 一个左值表达式代表的是对象本身，而右值表达式代表的是对象的值；变量也是左值。 绑定的对象（引用的对象）不同，左值引用绑定的是返回左值引用的函数、赋值、下标、解引用、前置递增递减 左值持久，右值短暂，右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户 使用右值引用的代码可以自由的接管所引用对象的内容 1int i = 0; // 在这条语句中，i 是左值，0 是临时值，就是右值。 123int &amp;a = 1; // error C2440: “初始化”: 无法从“int”转换为“int &amp;”1我们最多只能用常量引用来绑定一个右值，如： 在C++11中，我们可以引用右值，使用&amp;&amp;来实现：1int &amp;&amp;a = 1; 临时对象被使用完之后会被立即析构，在析构函数中free掉申请的内存资源。 如果能够直接使用临时对象已经申请的资源，并在其析构函数中取消对资源的释放，这样既能节省资源，有能节省资源申请和释放的时间。 右值引用并不能阻止编译器在临时对象使用完之后将其释放掉的事实，所以转移构造函数和转移赋值操作符重载函数 中都将_data赋值为了NULL，而且析构函数中保证了_data != NULL才会释放。 标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。 1234567template &lt;class T&gt; void swap(T&amp; a, T&amp; b) &#123; T tmp(a); // copy a to tmp a = b; // copy b to a b = tmp; // copy tmp to b &#125; 1234567template &lt;class T&gt;void swap(T&amp; a, T&amp; b) &#123; T tmp(std::move(a)); // move a to tmp a = std::move(b); // move b to a b = std::move(tmp); // move tmp to b &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++前置与后置]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%BD%AE%E4%B8%8E%E5%90%8E%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符，理由是 前置自增 (++i) 通常要比后置自增 (i++) 效率更高。 ++a表示取a的地址，增加它的内容，然后把值放在寄存器中； a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值； 前缀与后缀运算符重载1234567891011121314151617181920212223242526272829303132333435363738class Age &#123; public: Age&amp; operator++() //前置++ &#123; ++i; return *this; &#125; const Age operator++(int) //后置++ &#123; Age tmp = *this; ++(*this); //利用前置++ return tmp; &#125; Age&amp; operator=(int i) //赋值操作 &#123; this-&gt;i = i; return *this; &#125; private: int i; &#125;; int main() &#123; Age a; (a++)++; //编译错误 (右值) ++(a++); //编译错误 （右值） a++ = 1; //编译错误 （右值） (++a)++; //OK ++(++a); //OK ++a = 1; //OK &#125; a++的类型是const Age，返回的是右值，自然不能对它进行前置++、后置++、赋值等操作。同时会产生临时对象。 ++a的类型是Age&amp;，返回的是左值，当然可以对它进行前置++、后置++、赋值等操作 所以，在非内置类型的时候，尽量使用前置++，因为效率高（后置自增，效率低）]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存对齐]]></title>
    <url>%2F2019%2F05%2F04%2F-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[内存对齐规律 各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。 各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节自动填充。 同时为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 1、 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。 2、 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt; using namespace std; struct Test &#123; int a; //4 char b;//1+1 short c;//2 char d;//1+3 &#125;; struct Test1 &#123; int a; //4 char b;//1+1 short c;//2 char d;//1+6 double t;//8 &#125;;struct X1 &#123; int i;//4个字节 char c1;//1个字节 char c2;//1个字节&#125;; struct X2 &#123; char c1;//1个字节 int i;//4个字节 char c2;//1个字节 &#125;; struct X3 &#123; char c1;//1个字节 char c2;//1个字节 int i;//4个字节&#125;; int main() &#123; cout &lt;&lt; &quot;long &quot; &lt;&lt; sizeof(long) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;float &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;int &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;char &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;double &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot;\n&quot;; X1 x1; X2 x2; X3 x3; Test t; Test1 t1; cout &lt;&lt; &quot;x1 的大小 &quot; &lt;&lt; sizeof(x1) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;x2 的大小 &quot; &lt;&lt; sizeof(x2) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;x3 的大小 &quot; &lt;&lt; sizeof(x3) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;t 的大小 &quot; &lt;&lt; sizeof(t) &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;t1 的大小 &quot; &lt;&lt; sizeof(t1) &lt;&lt; &quot;\n&quot;; return 0; &#125; 输出结果：1234567891011long 4float 4int 4char 1double 8x1 的大小 8x2 的大小 12x3 的大小 8t 的大小 12t1 的大小 24 设置内存对齐字节数12345678910111213#pragma pack(4) //sizeof(Test1)=28#pragma pack(8) //sizeof(Test1)=32 VS 默认struct Test1 &#123; char c; short sh; int a; float f; int *p; char *s; double d; &#125;; 关于静态变量static静态变量的存放位置与结构体实例的存储地址无关，是单独存放在静态数据区的，因此用siezof计算其大小时没有将静态成员所占的空间计算进来。 关于类空类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 （一）类内部的成员变量： 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。 static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 （二）类内部的成员函数： 普通函数：不占用内存。 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 123//sizeof(cBase)=1#pragma pack(4) class cBase&#123;&#125;; 不包含虚函数时，对于类中的成员变量按结构体对齐方式处理，普通函数函数不占内存。sizeof(CBase1)=812345678910#pragma pack(4) class CBase1 &#123; private: char c; short sh; int a; public: void fOut()&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125; &#125;; 包含虚函数时，类中需要保存虚函数表的入口地址指针，即需要多保存一个指针。这个值跟虚函数的个数多少没有关系。sizeof(CBase2)=1212345678910#pragma pack(4) class CBase2 &#123; private: char c; short sh; int a; public: virtual void fOut()&#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125; &#125;; 子类所占内存大小是父类+自身成员变量的值。特别注意的是，子类与父类共享同一个虚函数指针，因此当子类新声明一个虚函数时，不必在对其保存虚函数表指针入口。1234567891011121314151617#pragma pack(4) class CBase2 &#123; private: char c; short sh; int a; public: virtual void fOut()&#123; cout &lt;&lt; &quot;virtual 1&quot; &lt;&lt; endl; &#125; &#125;; class cDerive :public CBase &#123; private : int n; public: virtual void fPut()&#123; cout &lt;&lt; &quot;virtual 2&quot;; &#125; &#125;;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp介绍与Hexo优化]]></title>
    <url>%2F2019%2F05%2F04%2FGulp%E4%BB%8B%E7%BB%8D%E4%B8%8EHexo%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是Gulpgulp.js是一种基于流的，代码优于配置的新一代构建工具。Gulp和Grunt类似。但相比于Grunt的频繁的I/O操作，Gulp的流操作，能更快完成构建。 Gulp特性 使用方便 通过代码优于配置的策略，Gulp可以让简单的任务简单，复杂的任务更可管理。 构建快速 通过流式操作，减少频繁的 IO 操作，更快地构建项目。 插件高质 Gulp 有严格的插件指导策略，确保插件能简单高质的工作。 易于学习 少量的API，掌握Gulp可以毫不费力。构建就像流管道一样，轻松加愉快。 Gulp安装Gulp是基于Node.js的，故要首先安装 Node.js。 npm install -g gulp 然后按以下清单文件安装12345gulpgulp-htmlcleangulp-htmlmingulp-minify-cssgulp-uglify 方法是同样的,npm install xxx –save，xxx即为清单列表文件名。其中gulp是工程的核心程序，Gulp采用插件方式进行工作，下面的5个文件就是基于Gulp的插件。 123456npm install gulp -g npm install gulp --savenpm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --save 使用Gulp优化Hexo建立gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243var gulp = require(&apos;gulp&apos;); //Plugins模块获取 var minifycss = require(&apos;gulp-minify-css&apos;); var uglify = require(&apos;gulp-uglify&apos;); var htmlmin = require(&apos;gulp-htmlmin&apos;); var htmlclean = require(&apos;gulp-htmlclean&apos;); // 压缩 public 目录 css文件 gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;)); &#125;); // 压缩 public 目录 html文件 gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;)) &#125;); // 压缩 public/js 目录 js文件 gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;)); &#125;); //4.0以前的写法 //gulp.task(&apos;default&apos;, [ // &apos;minify-html&apos;, &apos;minify-css&apos;, &apos;minify-js&apos; //]); //4.0以后的写法 // 执行 gulp 命令时执行的任务 gulp.task(&apos;default&apos;, gulp.parallel(&apos;minify-html&apos;, &apos;minify-css&apos;, &apos;minify-js&apos;, function() &#123; // Do something after a, b, and c are finished. &#125;)); 运行要运行gulp任务，只需切换到存放gulpfile.js文件的目录，然后在终端中执行gulp命令就行了，gulp后面可以加上要执行的任务名，例如gulp task1，如果没有指定任务名，则会执行任务名为default的默认任务。 12345hexo clean //先清除public目录hexo g //生成发布文件gulp //压缩代码hexo d //发布]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-admin设置用户名及密码]]></title>
    <url>%2F2019%2F05%2F01%2Fhexo-admin%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%8F%8A%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[安装hexo插件安装并使用hexo-admin123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ 设置后台密码修改站点配置文件_config.yml:12345# adminadmin: username: **** password_hash: ZwrRbx0gZl8myLbI9/oA4T4TxgSxE. secret: ***** username是用户名 password_hash是密码的哈希映射值，由于不同版本的node.js的哈希算法是不一样的，所有用以下方法来产生有效的密码哈希值1234$ node&gt; const bcrypt = require(&apos;bcrypt-nodejs&apos;)&gt; bcrypt.hashSync(&apos;your password secret here!&apos;)//=&gt; &apos;$2a$10$8f0CO288aEgpb0BQk0mAEOIDwPS.s6nl703xL6PLTVzM.758x8xsi&apos;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript call 用法及好处]]></title>
    <url>%2F2019%2F04%2F27%2FJavascript-call-%E7%94%A8%E6%B3%95%E5%8F%8A%E5%A5%BD%E5%A4%84%2F</url>
    <content type="text"><![CDATA[call 可以改变当前函数的作用域 示例 12345678910111213function Person(name)&#123; this.name=name;&#125;Person.prototype.say=function()&#123; console.log(&quot;My name is&quot;+this.name);&#125;var person =new Person(&quot;Mike&quot;);person.say();//My name is Mikevar student=&#123;name:&apos;Marry&apos;&#125;;person.call(student);// My name is Marry 好处使用call方法防止调用对象的原型方法被改变 12345678var slice=[].slice;//(保存未修改前的)Array.prototype.slice=function(index)&#123; console.log(&apos;我是改写的slice方法&apos;+index);&#125;var array=[1,2,3,4];slice.call(array,3);//print out 4 (未修改前的)array.slice(3);// print out 我是改写的slice方法4 (原型方法被修改掉了)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包、立即执行函数和模块化]]></title>
    <url>%2F2019%2F04%2F27%2FJS%E9%97%AD%E5%8C%85%E3%80%81%E7%AB%8B%E5%8D%B3%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[闭包一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 示例1、函数作为返回值12345678910111213//函数声明function fn()&#123; var max=10; return function bar(x)&#123; if(x&gt;max)&#123; console.log(x); &#125; &#125;;&#125;//函数表达式var f1=fu();f1(15); //print out 15//执行f(15)时，max变量的取值是10 2、函数作为参数被传递1234567891011121314var max=10, fn=function(x)&#123; if(x&gt;max)&#123; console.log(x); &#125; &#125;; (function(f)&#123; var max=100; f(15);&#125;)(fn);/*执行f(15)时，max变量的取值是10，而不是100*/ 立即执行函数立即执行函数立即执行，函数体后要有小括号以及函数必须是函数表达式（()、+、-、!等）而不能是函数声明 示例1、匿名函数包裹在一个括号运算符中，后面跟一个小括号 123(function(test)&#123; console.log(test); //print out 123&#125;)(123); 2、匿名函数后面跟小括号，然后整个包裹在括号运算符中 123(function(test)&#123; console.log(test);//print out 1234&#125;(1234)); 模块化1、使用立即执行函数 使用&quot;立即执行函数&quot;（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。 1234567891011121314151617181920var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); //使用上面的写法，外部代码无法读取内部的_count变量 console.info(module1._count); //undefined 2、放大模式 12345678910111213141516171819202122232425 var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod; &#125;)(module1);//上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。//宽放大模式var module1 = ( function (mod)&#123; //... return mod; &#125;)(window.module1 || &#123;&#125;);//模块的独立性 var module1 = (function ($, YAHOO) &#123; //... &#125;)(jQuery, YAHOO);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 模块加载]]></title>
    <url>%2F2019%2F04%2F27%2Fjavascript-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Javascript 模块加载分为浏览器端加载和服务器端加载。 CommonJS服务器端模块化的规范，Nodejs实现了这种规范。 规范 一个单独的JS文件就是一个module，拥有单独的作用域; 每个单独的module是一个单独的作用域。也就是说在一个文件里定义的变量和函数都是私有，对其他文件不可见，除非用exports导出了; 通过require来加载模块; 通过exports和module.exports来暴露模块中的内容。 CommonJS分为三部分： require 模块加载 exports 模块导出 module 模块本身 示例hello.js123exports.world=function()&#123; console.log(&apos;Hello World&apos;);&#125; main.js12var hello=require(&apos;./hello&apos;);hello.world(); 或hello.js12345678910function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log(&apos;Hello &apos; + name); &#125;; &#125;; module.exports = Hello; main.js1234var Hello = require(&apos;./hello&apos;); hello = new Hello(); hello.setName(&apos;BYVoid&apos;); hello.sayHello(); AMDAsynchronous Module Definition 的缩写，意思是异步模块定义，是一种异步模块加载的规范。 主要用于浏览器端的JS加载，为了不造成网络阻塞。只有当依赖的模块加载完毕，才会执行回调。 规范AMD使用define来定义模块，require来加载模块; AMD允许输出的模块兼容CommonJS; RequireJS是AMD的一种实现。 define(id?, dependencies?, factory); id：指定义中模块的名字 dependencies：是一个当前模块依赖的 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 示例1、定义模块 math.js1234567define([&apos;jquery&apos;], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 2、调用模块 main.js123require([&apos;jquery&apos;,&apos;math&apos;], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 3、统一1require([module], callback); 12345require([&apos;math&apos;], function (math) &#123; math.add(2, 3); &#125;); UMDUniversal Module Definition。 把前后端加载糅合在了一起，提供了一个前后端统一的解决方案。 支持AMD和CommonJS模式。 规范 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global） 示例 root &lt;– this factory &lt;– function (){} 123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], factory); &#125; else if (typeof exports === &apos;object&apos;) &#123; // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(); &#125;&#125;(this, function () &#123; // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++11新增的容器]]></title>
    <url>%2F2019%2F04%2F23%2Fc-11%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[array123456789101112131415161718192021222324#include &lt;string&gt;#include &lt;iterator&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;array&gt; int main()&#123; // construction uses aggregate initialization std::array&lt;int, 3&gt; a1&#123; &#123;1, 2, 3&#125; &#125;; // double-braces required in C++11 (not in C++14) std::array&lt;int, 3&gt; a2 = &#123;1, 2, 3&#125;; // never required after = std::array&lt;std::string, 2&gt; a3 = &#123; std::string(&quot;a&quot;), &quot;b&quot; &#125;; // container operations are supported std::sort(a1.begin(), a1.end()); std::reverse_copy(a2.begin(), a2.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)); std::cout &lt;&lt; &apos;\n&apos;; // ranged for loop is supported for(const auto&amp; s: a3) std::cout &lt;&lt; s &lt;&lt; &apos; &apos;;&#125; unordered_map &amp; unordered_set123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &quot;unordered_map.hpp&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt; //////////////////////////////////////////////////// reference: http://en.cppreference.com/w/cpp/container/unordered_mapint test_unordered_map1()&#123; // Create an unordered_map of three strings (that map to strings) std::unordered_map&lt;std::string, std::string&gt; u = &#123; &#123; &quot;RED&quot;, &quot;#FF0000&quot; &#125;, &#123; &quot;GREEN&quot;, &quot;#00FF00&quot; &#125;, &#123; &quot;BLUE&quot;, &quot;#0000FF&quot; &#125; &#125;; // Iterate and print keys and values of unordered_map for (const auto&amp; n : u) &#123; std::cout &lt;&lt; &quot;Key:[&quot; &lt;&lt; n.first &lt;&lt; &quot;] Value:[&quot; &lt;&lt; n.second &lt;&lt; &quot;]\n&quot;; &#125; // Add two new entries to the unordered_map u[&quot;BLACK&quot;] = &quot;#000000&quot;; u[&quot;WHITE&quot;] = &quot;#FFFFFF&quot;; // Output values by key std::cout &lt;&lt; &quot;The HEX of color RED is:[&quot; &lt;&lt; u[&quot;RED&quot;] &lt;&lt; &quot;]\n&quot;; std::cout &lt;&lt; &quot;The HEX of color BLACK is:[&quot; &lt;&lt; u[&quot;BLACK&quot;] &lt;&lt; &quot;]\n&quot;; std::cout &lt;&lt; &quot;The u&apos;s size: &quot; &lt;&lt; u.size() &lt;&lt; std::endl; return 0;&#125; /////////////////////////////////////////////////////// reference: http://www.cplusplus.com/reference/unordered_map/unordered_map/at/typedef std::unordered_map&lt;std::string, std::string&gt; stringmap; stringmap merge(stringmap a, stringmap b) &#123; stringmap temp(a); temp.insert(b.begin(), b.end()); return temp;&#125; int test_unordered_map2()&#123; ////////// at/size std::unordered_map&lt;std::string, int&gt; mymap = &#123; &#123; &quot;Mars&quot;, 3000 &#125;, &#123; &quot;Saturn&quot;, 60000 &#125;, &#123; &quot;Jupiter&quot;, 70000 &#125; &#125;; mymap.at(&quot;Mars&quot;) = 3396; mymap.at(&quot;Saturn&quot;) += 272; mymap.at(&quot;Jupiter&quot;) = mymap.at(&quot;Saturn&quot;) + 9638; for (auto&amp; x : mymap) &#123; std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;mymap.size() is &quot; &lt;&lt; mymap.size() &lt;&lt; std::endl; /////////// begin std::unordered_map&lt;std::string, std::string&gt; mymap2 = &#123; &#123; &quot;Australia&quot;, &quot;Canberra&quot; &#125;, &#123; &quot;U.S.&quot;, &quot;Washington&quot; &#125;, &#123; &quot;France&quot;, &quot;Paris&quot; &#125; &#125;; std::cout &lt;&lt; &quot;mymap2 contains:&quot;; for (auto it = mymap2.begin(); it != mymap2.end(); ++it) std::cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; it-&gt;second; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;mymap2&apos;s buckets contain:\n&quot;; for (unsigned i = 0; i &lt; mymap2.bucket_count(); ++i) &#123; std::cout &lt;&lt; &quot;bucket #&quot; &lt;&lt; i &lt;&lt; &quot; contains:&quot;; for (auto local_it = mymap2.begin(i); local_it != mymap2.end(i); ++local_it) std::cout &lt;&lt; &quot; &quot; &lt;&lt; local_it-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; local_it-&gt;second; std::cout &lt;&lt; std::endl; &#125; ////////////// bucket std::unordered_map&lt;std::string, std::string&gt; mymap3 = &#123; &#123; &quot;us&quot;, &quot;United States&quot; &#125;, &#123; &quot;uk&quot;, &quot;United Kingdom&quot; &#125;, &#123; &quot;fr&quot;, &quot;France&quot; &#125;, &#123; &quot;de&quot;, &quot;Germany&quot; &#125; &#125;; for (auto&amp; x : mymap3) &#123; std::cout &lt;&lt; &quot;Element [&quot; &lt;&lt; x.first &lt;&lt; &quot;:&quot; &lt;&lt; x.second &lt;&lt; &quot;]&quot;; std::cout &lt;&lt; &quot; is in bucket #&quot; &lt;&lt; mymap3.bucket(x.first) &lt;&lt; std::endl; &#125; /////////////// count std::unordered_map&lt;std::string, double&gt; mymap4 = &#123; &#123; &quot;Burger&quot;, 2.99 &#125;, &#123; &quot;Fries&quot;, 1.99 &#125;, &#123; &quot;Soda&quot;, 1.50 &#125; &#125;; for (auto&amp; x : &#123; &quot;Burger&quot;, &quot;Pizza&quot;, &quot;Salad&quot;, &quot;Soda&quot; &#125;) &#123; if (mymap4.count(x)&gt;0) std::cout &lt;&lt; &quot;mymap4 has &quot; &lt;&lt; x &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;mymap4 has no &quot; &lt;&lt; x &lt;&lt; std::endl; &#125; ///////////////// erase std::unordered_map&lt;std::string, std::string&gt; mymap5; // populating container: mymap5[&quot;U.S.&quot;] = &quot;Washington&quot;; mymap5[&quot;U.K.&quot;] = &quot;London&quot;; mymap5[&quot;France&quot;] = &quot;Paris&quot;; mymap5[&quot;Russia&quot;] = &quot;Moscow&quot;; mymap5[&quot;China&quot;] = &quot;Beijing&quot;; mymap5[&quot;Germany&quot;] = &quot;Berlin&quot;; mymap5[&quot;Japan&quot;] = &quot;Tokyo&quot;; // erase examples: mymap5.erase(mymap5.begin()); // erasing by iterator mymap5.erase(&quot;France&quot;); // erasing by key mymap5.erase(mymap5.find(&quot;China&quot;), mymap5.end()); // erasing by range // show content: for (auto&amp; x : mymap5) std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; ////////////////////// find std::unordered_map&lt;std::string, double&gt; mymap6 = &#123; &#123; &quot;mom&quot;, 5.4 &#125;, &#123; &quot;dad&quot;, 6.1 &#125;, &#123; &quot;bro&quot;, 5.9 &#125; &#125;; std::string input; std::cout &lt;&lt; &quot;who? &quot;; getline(std::cin, input); std::unordered_map&lt;std::string, double&gt;::const_iterator got = mymap6.find(input); if (got == mymap6.end()) std::cout &lt;&lt; &quot;not found&quot;; else std::cout &lt;&lt; got-&gt;first &lt;&lt; &quot; is &quot; &lt;&lt; got-&gt;second; std::cout &lt;&lt; std::endl; //////////////////// insert std::unordered_map&lt;std::string, double&gt; myrecipe, mypantry = &#123; &#123; &quot;milk&quot;, 2.0 &#125;, &#123; &quot;flour&quot;, 1.5 &#125; &#125;; std::pair&lt;std::string, double&gt; myshopping(&quot;baking powder&quot;, 0.3); myrecipe.insert(myshopping); // copy insertion myrecipe.insert(std::make_pair&lt;std::string, double&gt;(&quot;eggs&quot;, 6.0)); // move insertion myrecipe.insert(mypantry.begin(), mypantry.end()); // range insertion myrecipe.insert(&#123; &#123; &quot;sugar&quot;, 0.8 &#125;, &#123; &quot;salt&quot;, 0.1 &#125; &#125;); // initializer list insertion std::cout &lt;&lt; &quot;myrecipe contains:&quot; &lt;&lt; std::endl; for (auto&amp; x : myrecipe) std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; //////////////////// = stringmap first = &#123; &#123; &quot;AAPL&quot;, &quot;Apple&quot; &#125;, &#123; &quot;MSFT&quot;, &quot;Microsoft&quot; &#125; &#125;; // init list stringmap second = &#123; &#123; &quot;GOOG&quot;, &quot;Google&quot; &#125;, &#123; &quot;ORCL&quot;, &quot;Oracle&quot; &#125; &#125;; // init list stringmap third = merge(first, second); // move first = third; // copy std::cout &lt;&lt; &quot;first contains:&quot;; for (auto&amp; elem : first) std::cout &lt;&lt; &quot; &quot; &lt;&lt; elem.first &lt;&lt; &quot;:&quot; &lt;&lt; elem.second; std::cout &lt;&lt; std::endl; return 0;&#125; //////////////////////////////////////////////////////// reference: http://www.geeksforgeeks.org/unordered_map-in-stl-and-its-applications/int test_unordered_map3()&#123; // key will be of string type and mapped value will be of double type std::unordered_map&lt;std::string, double&gt; umap; // inserting values by using [] operator umap[&quot;PI&quot;] = 3.14; umap[&quot;root2&quot;] = 1.414; umap[&quot;root3&quot;] = 1.732; umap[&quot;log10&quot;] = 2.302; umap[&quot;loge&quot;] = 1.0; // inserting value by insert function umap.insert(std::make_pair(&quot;e&quot;, 2.718)); std::string key = &quot;PI&quot;; // If key not found in map iterator to end is returned if (umap.find(key) == umap.end()) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; not found\n\n&quot;; &#125; else &#123;// If key found then iterator to that key is returned std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; key &lt;&lt; &quot;\n\n&quot;; &#125; key = &quot;lambda&quot;; if (umap.find(key) == umap.end()) std::cout &lt;&lt; key &lt;&lt; &quot; not found\n&quot;; else std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; key &lt;&lt; std::endl; // iterating over all value of umap std::unordered_map&lt;std::string, double&gt;::iterator itr; std::cout &lt;&lt; &quot;\nAll Elements : \n&quot;; for (itr = umap.begin(); itr != umap.end(); itr++) &#123; // itr works as a pointer to pair&lt;string, double&gt; type itr-&gt;first stores the key part // and itr-&gt;second stroes the value part std::cout &lt;&lt; itr-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; itr-&gt;second &lt;&lt; std::endl; &#125; return 0;&#125; 非成员begin\end1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt; int main() &#123; std::vector&lt;int&gt; v = &#123; 3, 1, 4 &#125;; auto vi = std::begin(v); std::cout &lt;&lt; *vi &lt;&lt; &apos;\n&apos;; int a[] = &#123; -5, 10, 15 &#125;; auto ai = std::begin(a); std::cout &lt;&lt; *ai &lt;&lt; &apos;\n&apos;;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 删除远程分支]]></title>
    <url>%2F2019%2F02%2F20%2Fgit-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[git branch -r 查看远程分支git branch -r -d origin/AirportProducts 删除本地远程分支 AirportProducts branch-namegit push origin :AirportProducts 删除远程仓库的分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeSnippet C language]]></title>
    <url>%2F2019%2F01%2F31%2FCodeSnippet-FILE%2F</url>
    <content type="text"><![CDATA[使用OutputDebugString输出调试信息1234567891011121314151617void __cdecl odprintf(const char* fmt, ...)&#123; char buf[4096], *p = buf; va_list args; va_start(args, fmt); p += vsnprintf_s(p, sizeof(buf), _TRUNCATE, fmt, args); va_end(args); while (p &gt; buf &amp;&amp; isspace(p[-1])) *--p = &apos;\0&apos;; *p++ = &apos;\r&apos;; *p++ = &apos;\n&apos;; *p = &apos;\0&apos;; OutputDebugString(buf); //OutputDebugString &#125; 时间戳转字符日期123456void __cdecl dateprintf(long long timestamp, char*now,int len) &#123; struct tm ttime; localtime_s(&amp;ttime, &amp;timestamp); strftime(now, len, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;ttime);&#125; 按行读取文本文件到map1234567891011121314151617181920212223242526272829303132333435#include&lt;io.h&gt;std::map&lt;CameraId, int&gt; m_recordloc;int find_view_by_cid(int cid) &#123; auto it = m_recordloc.find(cid); return it != m_recordloc.end() ? it-&gt;second : 1;&#125;void getRecordLocation() &#123; odprintf(&quot;[HK8600] %s\n&quot;, __FUNCTION__); if (!_access(&quot;device_tr.dat&quot;, 0)) &#123; odprintf(&quot;[HK8600] %s\n&quot;, &quot;device_tr.dat EXISITS!&quot;); FILE *file = fopen(&quot;device_tr.dat&quot;, &quot;r&quot;); if (file != NULL) &#123; while (!feof(file)) &#123; int cameraId, reloc; fscanf(file, &quot;%d,%d&quot;, &amp;cameraId, &amp;reloc); odprintf(&quot;[HK8600] cameraId:%d;location:%d\n&quot;,cameraId,reloc); m_recordloc.insert(std::make_pair(cameraId, reloc)); &#125; &#125; else &#123; odprintf(&quot;[HK8600] %s\n&quot;, &quot;Read device_tr.dat FAILED!&quot;); &#125; fclose(file); &#125; else odprintf(&quot;[HK8600] %s\n&quot;,&quot;DOESN&apos;T EXISIT!&quot;);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[负载均衡算法]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[轮询算法（round-robin）1234567891011SERVER_LIST = [ &apos;10.246.10.1&apos;, &apos;10.246.10.2&apos;, &apos;10.246.10.3&apos;,]def round_robin(server_lst, cur = [0]): length = len(server_lst) ret = server_lst[cur[0] % length] cur[0] = (cur[0] + 1) % length return ret 加权轮询算法（weight round-robin）12345678910111213141516WEIGHT_SERVER_LIST = &#123; &apos;10.246.10.1&apos;: 1, &apos;10.246.10.2&apos;: 3, &apos;10.246.10.3&apos;: 2,&#125;def weight_round_robin(servers, cur = [0]): weighted_list = [] //[ &apos;10.246.10.1&apos;,10.246.10.2&apos;,10.246.10.2&apos;,10.246.10.2&apos;,&apos;10.246.10.3&apos;,&apos;10.246.10.3&apos;] for k, v in servers.iteritems(): weighted_list.extend([k] * v) length = len(weighted_list) ret = weighted_list[cur[0] % length] cur[0] = (cur[0] + 1) % length return ret 随机算法（random）1234def random_choose(server_lst): import random random.seed() return random.choice(server_lst) 加权随机算法（random）1234567def weight_random_choose(servers): import random random.seed() weighted_list = [] for k, v in servers.iteritems(): weighted_list.extend([k] * v) return random.choice(weighted_list) 归一化(概率)12345678910111213141516171819def normalize_servers(servers): normalized_servers = &#123;&#125; total = sum(servers.values()) cur_sum = 0 for k, v in servers.iteritems(): normalized_servers[k] = 1.0 * (cur_sum + v) / total cur_sum += v return normalized_serversdef weight_random_choose_ex(normalized_servers): import random, operator random.seed() rand = random.random() //按照归一化加权值排序 for k, v in sorted(normalized_servers.iteritems(), key = operator.itemgetter(1)): if v &gt;= rand: return k else: assert False, &apos;Error normalized_servers with rand %s &apos; % rand 哈希法（hash）1234//同一个请求能够分配到同样的服务节点，这对于“有状态”的服务很有必要 def hash_choose(request_info, server_lst): hashed_request_info = hash(request_info) return server_lst[hashed_request_info % len(server_lst)] 一致性哈希最少连接算法（least connection）]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python venv]]></title>
    <url>%2F2019%2F01%2F20%2Fpython-venv%2F</url>
    <content type="text"><![CDATA[安装Anaconda配置Anaconda 包源1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 使用Anaconda123456789101112131415//列出安装包conda list //列出python虚拟环境conda env list//创建一个python虚拟环境python3.5conda create -n python3.5 python=3.5//激活python3.5虚拟环境activate python3.5//为python3.5虚拟环境安装virtualenv环境conda install -n python3.5 virtualenv//解除虚拟环境deactivate//删除python3.5虚拟环境conda remove -n python3.5 --allconda remove --name python3.5 virtualenv 切换安装32位和64包123456//切换到32位版本set CONDA_FORCE_32BIT=1//切换到64位版本set CONDA_FORCE_32BIT=// 查看环境信息conda info python包管理 基本原则是使用Anconda管理多个版本的python环境，使用pip及virtualenv管理python环境的副本及三方库。 12345678910111213//anaconda 管理python多版本切换conda create -n python3.5 python=3.5active python3.5pip install virtualenv// 纯净python环境virtualenv --no-site-packages venv /venv/Script/activate//备份三方python包pip freeze &gt; requirement.txt//批量安装python三方包pip install -r requirement.txt/venv/Script/deactivatedeactivate]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multi-hexo-writing]]></title>
    <url>%2F2019%2F01%2F07%2Fmulti-hexo-writing%2F</url>
    <content type="text"><![CDATA[安装nodejs环境12conda install nodejsnpm install -g hexo-cli 克隆远程GIT到本地12git clone xxxx.gitnpm install]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tips]]></title>
    <url>%2F2019%2F01%2F06%2Fhexo_tips%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
