<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包、立即执行函数和模块化]]></title>
    <url>%2F2019%2F04%2F27%2FJS%E9%97%AD%E5%8C%85%E3%80%81%E7%AB%8B%E5%8D%B3%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[闭包一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 模块加载]]></title>
    <url>%2F2019%2F04%2F27%2Fjavascript-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Javascript 模块加载分为浏览器端加载和服务器端加载。 CommonJS服务器端模块化的规范，Nodejs实现了这种规范。 规范 一个单独的JS文件就是一个module，拥有单独的作用域; 每个单独的module是一个单独的作用域。也就是说在一个文件里定义的变量和函数都是私有，对其他文件不可见，除非用exports导出了; 通过require来加载模块; 通过exports和module.exports来暴露模块中的内容。 CommonJS分为三部分： require 模块加载 exports 模块导出 module 模块本身 示例hello.js123exports.world=function()&#123; console.log(&apos;Hello World&apos;);&#125; main.js12var hello=require(&apos;./hello&apos;);hello.world(); 或hello.js12345678910function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log(&apos;Hello &apos; + name); &#125;; &#125;; module.exports = Hello; main.js1234var Hello = require(&apos;./hello&apos;); hello = new Hello(); hello.setName(&apos;BYVoid&apos;); hello.sayHello(); AMDAsynchronous Module Definition 的缩写，意思是异步模块定义，是一种异步模块加载的规范。 主要用于浏览器端的JS加载，为了不造成网络阻塞。只有当依赖的模块加载完毕，才会执行回调。 规范AMD使用define来定义模块，require来加载模块; AMD允许输出的模块兼容CommonJS; RequireJS是AMD的一种实现。 define(id?, dependencies?, factory); id：指定义中模块的名字 dependencies：是一个当前模块依赖的 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 示例1、定义模块 math.js1234567define([&apos;jquery&apos;], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 2、调用模块 main.js123require([&apos;jquery&apos;,&apos;math&apos;], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); UMDUniversal Module Definition。 把前后端加载糅合在了一起，提供了一个前后端统一的解决方案。 支持AMD和CommonJS模式。 规范 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global） 示例 root &lt;– this factory &lt;– function (){} 123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], factory); &#125; else if (typeof exports === &apos;object&apos;) &#123; // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(); &#125;&#125;(this, function () &#123; // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++11新增的容器]]></title>
    <url>%2F2019%2F04%2F23%2Fc-11%E6%96%B0%E5%A2%9E%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[array123456789101112131415161718192021222324#include &lt;string&gt;#include &lt;iterator&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;array&gt; int main()&#123; // construction uses aggregate initialization std::array&lt;int, 3&gt; a1&#123; &#123;1, 2, 3&#125; &#125;; // double-braces required in C++11 (not in C++14) std::array&lt;int, 3&gt; a2 = &#123;1, 2, 3&#125;; // never required after = std::array&lt;std::string, 2&gt; a3 = &#123; std::string(&quot;a&quot;), &quot;b&quot; &#125;; // container operations are supported std::sort(a1.begin(), a1.end()); std::reverse_copy(a2.begin(), a2.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)); std::cout &lt;&lt; &apos;\n&apos;; // ranged for loop is supported for(const auto&amp; s: a3) std::cout &lt;&lt; s &lt;&lt; &apos; &apos;;&#125; unordered_map &amp; unordered_set123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &quot;unordered_map.hpp&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt; //////////////////////////////////////////////////// reference: http://en.cppreference.com/w/cpp/container/unordered_mapint test_unordered_map1()&#123; // Create an unordered_map of three strings (that map to strings) std::unordered_map&lt;std::string, std::string&gt; u = &#123; &#123; &quot;RED&quot;, &quot;#FF0000&quot; &#125;, &#123; &quot;GREEN&quot;, &quot;#00FF00&quot; &#125;, &#123; &quot;BLUE&quot;, &quot;#0000FF&quot; &#125; &#125;; // Iterate and print keys and values of unordered_map for (const auto&amp; n : u) &#123; std::cout &lt;&lt; &quot;Key:[&quot; &lt;&lt; n.first &lt;&lt; &quot;] Value:[&quot; &lt;&lt; n.second &lt;&lt; &quot;]\n&quot;; &#125; // Add two new entries to the unordered_map u[&quot;BLACK&quot;] = &quot;#000000&quot;; u[&quot;WHITE&quot;] = &quot;#FFFFFF&quot;; // Output values by key std::cout &lt;&lt; &quot;The HEX of color RED is:[&quot; &lt;&lt; u[&quot;RED&quot;] &lt;&lt; &quot;]\n&quot;; std::cout &lt;&lt; &quot;The HEX of color BLACK is:[&quot; &lt;&lt; u[&quot;BLACK&quot;] &lt;&lt; &quot;]\n&quot;; std::cout &lt;&lt; &quot;The u&apos;s size: &quot; &lt;&lt; u.size() &lt;&lt; std::endl; return 0;&#125; /////////////////////////////////////////////////////// reference: http://www.cplusplus.com/reference/unordered_map/unordered_map/at/typedef std::unordered_map&lt;std::string, std::string&gt; stringmap; stringmap merge(stringmap a, stringmap b) &#123; stringmap temp(a); temp.insert(b.begin(), b.end()); return temp;&#125; int test_unordered_map2()&#123; ////////// at/size std::unordered_map&lt;std::string, int&gt; mymap = &#123; &#123; &quot;Mars&quot;, 3000 &#125;, &#123; &quot;Saturn&quot;, 60000 &#125;, &#123; &quot;Jupiter&quot;, 70000 &#125; &#125;; mymap.at(&quot;Mars&quot;) = 3396; mymap.at(&quot;Saturn&quot;) += 272; mymap.at(&quot;Jupiter&quot;) = mymap.at(&quot;Saturn&quot;) + 9638; for (auto&amp; x : mymap) &#123; std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;mymap.size() is &quot; &lt;&lt; mymap.size() &lt;&lt; std::endl; /////////// begin std::unordered_map&lt;std::string, std::string&gt; mymap2 = &#123; &#123; &quot;Australia&quot;, &quot;Canberra&quot; &#125;, &#123; &quot;U.S.&quot;, &quot;Washington&quot; &#125;, &#123; &quot;France&quot;, &quot;Paris&quot; &#125; &#125;; std::cout &lt;&lt; &quot;mymap2 contains:&quot;; for (auto it = mymap2.begin(); it != mymap2.end(); ++it) std::cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; it-&gt;second; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;mymap2&apos;s buckets contain:\n&quot;; for (unsigned i = 0; i &lt; mymap2.bucket_count(); ++i) &#123; std::cout &lt;&lt; &quot;bucket #&quot; &lt;&lt; i &lt;&lt; &quot; contains:&quot;; for (auto local_it = mymap2.begin(i); local_it != mymap2.end(i); ++local_it) std::cout &lt;&lt; &quot; &quot; &lt;&lt; local_it-&gt;first &lt;&lt; &quot;:&quot; &lt;&lt; local_it-&gt;second; std::cout &lt;&lt; std::endl; &#125; ////////////// bucket std::unordered_map&lt;std::string, std::string&gt; mymap3 = &#123; &#123; &quot;us&quot;, &quot;United States&quot; &#125;, &#123; &quot;uk&quot;, &quot;United Kingdom&quot; &#125;, &#123; &quot;fr&quot;, &quot;France&quot; &#125;, &#123; &quot;de&quot;, &quot;Germany&quot; &#125; &#125;; for (auto&amp; x : mymap3) &#123; std::cout &lt;&lt; &quot;Element [&quot; &lt;&lt; x.first &lt;&lt; &quot;:&quot; &lt;&lt; x.second &lt;&lt; &quot;]&quot;; std::cout &lt;&lt; &quot; is in bucket #&quot; &lt;&lt; mymap3.bucket(x.first) &lt;&lt; std::endl; &#125; /////////////// count std::unordered_map&lt;std::string, double&gt; mymap4 = &#123; &#123; &quot;Burger&quot;, 2.99 &#125;, &#123; &quot;Fries&quot;, 1.99 &#125;, &#123; &quot;Soda&quot;, 1.50 &#125; &#125;; for (auto&amp; x : &#123; &quot;Burger&quot;, &quot;Pizza&quot;, &quot;Salad&quot;, &quot;Soda&quot; &#125;) &#123; if (mymap4.count(x)&gt;0) std::cout &lt;&lt; &quot;mymap4 has &quot; &lt;&lt; x &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;mymap4 has no &quot; &lt;&lt; x &lt;&lt; std::endl; &#125; ///////////////// erase std::unordered_map&lt;std::string, std::string&gt; mymap5; // populating container: mymap5[&quot;U.S.&quot;] = &quot;Washington&quot;; mymap5[&quot;U.K.&quot;] = &quot;London&quot;; mymap5[&quot;France&quot;] = &quot;Paris&quot;; mymap5[&quot;Russia&quot;] = &quot;Moscow&quot;; mymap5[&quot;China&quot;] = &quot;Beijing&quot;; mymap5[&quot;Germany&quot;] = &quot;Berlin&quot;; mymap5[&quot;Japan&quot;] = &quot;Tokyo&quot;; // erase examples: mymap5.erase(mymap5.begin()); // erasing by iterator mymap5.erase(&quot;France&quot;); // erasing by key mymap5.erase(mymap5.find(&quot;China&quot;), mymap5.end()); // erasing by range // show content: for (auto&amp; x : mymap5) std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; ////////////////////// find std::unordered_map&lt;std::string, double&gt; mymap6 = &#123; &#123; &quot;mom&quot;, 5.4 &#125;, &#123; &quot;dad&quot;, 6.1 &#125;, &#123; &quot;bro&quot;, 5.9 &#125; &#125;; std::string input; std::cout &lt;&lt; &quot;who? &quot;; getline(std::cin, input); std::unordered_map&lt;std::string, double&gt;::const_iterator got = mymap6.find(input); if (got == mymap6.end()) std::cout &lt;&lt; &quot;not found&quot;; else std::cout &lt;&lt; got-&gt;first &lt;&lt; &quot; is &quot; &lt;&lt; got-&gt;second; std::cout &lt;&lt; std::endl; //////////////////// insert std::unordered_map&lt;std::string, double&gt; myrecipe, mypantry = &#123; &#123; &quot;milk&quot;, 2.0 &#125;, &#123; &quot;flour&quot;, 1.5 &#125; &#125;; std::pair&lt;std::string, double&gt; myshopping(&quot;baking powder&quot;, 0.3); myrecipe.insert(myshopping); // copy insertion myrecipe.insert(std::make_pair&lt;std::string, double&gt;(&quot;eggs&quot;, 6.0)); // move insertion myrecipe.insert(mypantry.begin(), mypantry.end()); // range insertion myrecipe.insert(&#123; &#123; &quot;sugar&quot;, 0.8 &#125;, &#123; &quot;salt&quot;, 0.1 &#125; &#125;); // initializer list insertion std::cout &lt;&lt; &quot;myrecipe contains:&quot; &lt;&lt; std::endl; for (auto&amp; x : myrecipe) std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot; &lt;&lt; x.second &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; //////////////////// = stringmap first = &#123; &#123; &quot;AAPL&quot;, &quot;Apple&quot; &#125;, &#123; &quot;MSFT&quot;, &quot;Microsoft&quot; &#125; &#125;; // init list stringmap second = &#123; &#123; &quot;GOOG&quot;, &quot;Google&quot; &#125;, &#123; &quot;ORCL&quot;, &quot;Oracle&quot; &#125; &#125;; // init list stringmap third = merge(first, second); // move first = third; // copy std::cout &lt;&lt; &quot;first contains:&quot;; for (auto&amp; elem : first) std::cout &lt;&lt; &quot; &quot; &lt;&lt; elem.first &lt;&lt; &quot;:&quot; &lt;&lt; elem.second; std::cout &lt;&lt; std::endl; return 0;&#125; //////////////////////////////////////////////////////// reference: http://www.geeksforgeeks.org/unordered_map-in-stl-and-its-applications/int test_unordered_map3()&#123; // key will be of string type and mapped value will be of double type std::unordered_map&lt;std::string, double&gt; umap; // inserting values by using [] operator umap[&quot;PI&quot;] = 3.14; umap[&quot;root2&quot;] = 1.414; umap[&quot;root3&quot;] = 1.732; umap[&quot;log10&quot;] = 2.302; umap[&quot;loge&quot;] = 1.0; // inserting value by insert function umap.insert(std::make_pair(&quot;e&quot;, 2.718)); std::string key = &quot;PI&quot;; // If key not found in map iterator to end is returned if (umap.find(key) == umap.end()) &#123; std::cout &lt;&lt; key &lt;&lt; &quot; not found\n\n&quot;; &#125; else &#123;// If key found then iterator to that key is returned std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; key &lt;&lt; &quot;\n\n&quot;; &#125; key = &quot;lambda&quot;; if (umap.find(key) == umap.end()) std::cout &lt;&lt; key &lt;&lt; &quot; not found\n&quot;; else std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; key &lt;&lt; std::endl; // iterating over all value of umap std::unordered_map&lt;std::string, double&gt;::iterator itr; std::cout &lt;&lt; &quot;\nAll Elements : \n&quot;; for (itr = umap.begin(); itr != umap.end(); itr++) &#123; // itr works as a pointer to pair&lt;string, double&gt; type itr-&gt;first stores the key part // and itr-&gt;second stroes the value part std::cout &lt;&lt; itr-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; itr-&gt;second &lt;&lt; std::endl; &#125; return 0;&#125; 非成员begin\end1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt; int main() &#123; std::vector&lt;int&gt; v = &#123; 3, 1, 4 &#125;; auto vi = std::begin(v); std::cout &lt;&lt; *vi &lt;&lt; &apos;\n&apos;; int a[] = &#123; -5, 10, 15 &#125;; auto ai = std::begin(a); std::cout &lt;&lt; *ai &lt;&lt; &apos;\n&apos;;&#125;]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 删除远程分支]]></title>
    <url>%2F2019%2F02%2F20%2Fgit-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[git branch -r 查看远程分支git branch -r -d origin/AirportProducts 删除本地远程分支 AirportProducts branch-namegit push origin :AirportProducts 删除远程仓库的分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeSnippet C language]]></title>
    <url>%2F2019%2F01%2F31%2FCodeSnippet-FILE%2F</url>
    <content type="text"><![CDATA[使用OutputDebugString输出调试信息1234567891011121314151617void __cdecl odprintf(const char* fmt, ...)&#123; char buf[4096], *p = buf; va_list args; va_start(args, fmt); p += vsnprintf_s(p, sizeof(buf), _TRUNCATE, fmt, args); va_end(args); while (p &gt; buf &amp;&amp; isspace(p[-1])) *--p = &apos;\0&apos;; *p++ = &apos;\r&apos;; *p++ = &apos;\n&apos;; *p = &apos;\0&apos;; OutputDebugString(buf); //OutputDebugString &#125; 时间戳转字符日期123456void __cdecl dateprintf(long long timestamp, char*now,int len) &#123; struct tm ttime; localtime_s(&amp;ttime, &amp;timestamp); strftime(now, len, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;ttime);&#125; 按行读取文本文件到map1234567891011121314151617181920212223242526272829303132333435#include&lt;io.h&gt;std::map&lt;CameraId, int&gt; m_recordloc;int find_view_by_cid(int cid) &#123; auto it = m_recordloc.find(cid); return it != m_recordloc.end() ? it-&gt;second : 1;&#125;void getRecordLocation() &#123; odprintf(&quot;[HK8600] %s\n&quot;, __FUNCTION__); if (!_access(&quot;device_tr.dat&quot;, 0)) &#123; odprintf(&quot;[HK8600] %s\n&quot;, &quot;device_tr.dat EXISITS!&quot;); FILE *file = fopen(&quot;device_tr.dat&quot;, &quot;r&quot;); if (file != NULL) &#123; while (!feof(file)) &#123; int cameraId, reloc; fscanf(file, &quot;%d,%d&quot;, &amp;cameraId, &amp;reloc); odprintf(&quot;[HK8600] cameraId:%d;location:%d\n&quot;,cameraId,reloc); m_recordloc.insert(std::make_pair(cameraId, reloc)); &#125; &#125; else &#123; odprintf(&quot;[HK8600] %s\n&quot;, &quot;Read device_tr.dat FAILED!&quot;); &#125; fclose(file); &#125; else odprintf(&quot;[HK8600] %s\n&quot;,&quot;DOESN&apos;T EXISIT!&quot;);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[负载均衡算法]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[轮询算法（round-robin）1234567891011SERVER_LIST = [ &apos;10.246.10.1&apos;, &apos;10.246.10.2&apos;, &apos;10.246.10.3&apos;,]def round_robin(server_lst, cur = [0]): length = len(server_lst) ret = server_lst[cur[0] % length] cur[0] = (cur[0] + 1) % length return ret 加权轮询算法（weight round-robin）12345678910111213141516WEIGHT_SERVER_LIST = &#123; &apos;10.246.10.1&apos;: 1, &apos;10.246.10.2&apos;: 3, &apos;10.246.10.3&apos;: 2,&#125;def weight_round_robin(servers, cur = [0]): weighted_list = [] //[ &apos;10.246.10.1&apos;,10.246.10.2&apos;,10.246.10.2&apos;,10.246.10.2&apos;,&apos;10.246.10.3&apos;,&apos;10.246.10.3&apos;] for k, v in servers.iteritems(): weighted_list.extend([k] * v) length = len(weighted_list) ret = weighted_list[cur[0] % length] cur[0] = (cur[0] + 1) % length return ret 随机算法（random）1234def random_choose(server_lst): import random random.seed() return random.choice(server_lst) 加权随机算法（random）1234567def weight_random_choose(servers): import random random.seed() weighted_list = [] for k, v in servers.iteritems(): weighted_list.extend([k] * v) return random.choice(weighted_list) 归一化(概率)12345678910111213141516171819def normalize_servers(servers): normalized_servers = &#123;&#125; total = sum(servers.values()) cur_sum = 0 for k, v in servers.iteritems(): normalized_servers[k] = 1.0 * (cur_sum + v) / total cur_sum += v return normalized_serversdef weight_random_choose_ex(normalized_servers): import random, operator random.seed() rand = random.random() //按照归一化加权值排序 for k, v in sorted(normalized_servers.iteritems(), key = operator.itemgetter(1)): if v &gt;= rand: return k else: assert False, &apos;Error normalized_servers with rand %s &apos; % rand 哈希法（hash）1234//同一个请求能够分配到同样的服务节点，这对于“有状态”的服务很有必要 def hash_choose(request_info, server_lst): hashed_request_info = hash(request_info) return server_lst[hashed_request_info % len(server_lst)] 一致性哈希最少连接算法（least connection）]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python venv]]></title>
    <url>%2F2019%2F01%2F20%2Fpython-venv%2F</url>
    <content type="text"><![CDATA[安装Anaconda配置Anaconda 包源1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes 使用Anaconda123456789101112131415//列出安装包conda list //列出python虚拟环境conda env list//创建一个python虚拟环境python3.5conda create -n python3.5 python=3.5//激活python3.5虚拟环境activate python3.5//为python3.5虚拟环境安装virtualenv环境conda install -n python3.5 virtualenv//解除虚拟环境deactivate//删除python3.5虚拟环境conda remove -n python3.5 --allconda remove --name python3.5 virtualenv 切换安装32位和64包123456//切换到32位版本set CONDA_FORCE_32BIT=1//切换到64位版本set CONDA_FORCE_32BIT=// 查看环境信息conda info python包管理 基本原则是使用Anconda管理多个版本的python环境，使用pip及virtualenv管理python环境的副本及三方库。 12345678910111213//anaconda 管理python多版本切换conda create -n python3.5 python=3.5active python3.5pip install virtualenv// 纯净python环境virtualenv --no-site-packages venv /venv/Script/activate//备份三方python包pip freeze &gt; requirement.txt//批量安装python三方包pip install -r requirement.txt/venv/Script/deactivatedeactivate]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multi-hexo-writing]]></title>
    <url>%2F2019%2F01%2F07%2Fmulti-hexo-writing%2F</url>
    <content type="text"><![CDATA[安装nodejs环境12conda install nodejsnpm install -g hexo-cli 克隆远程GIT到本地12git clone xxxx.gitnpm install]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Tips]]></title>
    <url>%2F2019%2F01%2F06%2Fhexo_tips%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
